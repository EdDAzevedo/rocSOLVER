
#include "rocsolver_refactor.h"
#include "hip_check.h"
#include "hipsparse_check.h"


extern "C" {

rocsolverStatus_t
rocsolverRfAccessBundledFactors( /* Input */
                                 rocsolverRfHandle_t handle,
                                 /* Output (in the host memory ) */
                                 int *nnzM,
                                 /* Output (in the device memory) */
                                 int** Mp,
                                 int** Mi,
                                 double** Mx) 
{
   /*
    ----------------------------------
    matrix M = (L - eye) + U, 
    L has unit diagonal and not stored

    L, and U generated by rocsolverRfRefactor()
    ----------------------------------
   */
  if (handle == nullptr) {
     return( ROCSOLVER_STATUS_NOT_INITIALIZED );
     };

  if (handle->hipsparse_handle == nullptr) {
     return( ROCSOLVER_STATUS_NOT_INITIALIZED );
     };

  {
  bool const isok = (handle->csrRowPtrLU != nullptr) &&
                    (handle->csrColIndLU != nullptr) &&
                    (handle->csrValLU != nullptr);
  if (!isok) {
    return( ROCSOLVER_STATUS_NOT_INITIALIZED );
    };
  };

  hipStream_t streamId;

  HIPSPARSE_CHECK( hipsparseGetStream( handle->hipsparse_handle, &streamId ),
                   ROCSOLVER_STATUS_EXECUTION_FAILED );
                   
  *nnzM = handle->nnz_LU;
  
  
  /*
   ------------------------------------------------------
   Copy only the pointers, not the contents of the arrays
   ------------------------------------------------------
   */
   
  {
  void *dst = Mp;
  const void *src = &(handle->csrRowPtrLU);
  size_t sizeBytes = sizeof( *Mp );
  hipMemcpyKind kind = hipMemcpyDeviceToDevice;
  HIP_CHECK( hipMemcpyAsync( dst, src, sizeBytes, kind, streamId ),
             ROCSOLVER_STATUS_EXECUTION_FAILED );
  };

   {
   void *dst = Mi;
   const void *src = &(handle->csrColIndLU);
   size_t sizeBytes = sizeof( *Mi );
   hipMemcpyKind kind = hipMemcpyDeviceToDevice;
   HIP_CHECK( hipMemcpyAsync( dst, src, sizeBytes, kind, streamId ),
	      ROCSOLVER_STATUS_EXECUTION_FAILED );
   };
   
   {
   void *dst = Mx;
   const void *src = &(handle->csrValLU);
   size_t sizeBytes = sizeof( *Mx );
   hipMemcpyKind kind = hipMemcpyDeviceToDevice;
   HIP_CHECK( hipMemcpyAsync( dst, src, sizeBytes, kind, streamId ),
	      ROCSOLVER_STATUS_EXECUTION_FAILED );
   };

  {
  HIP_CHECK( hipStreamSynchronize( streamId ),
             ROCSOLVER_STATUS_EXECUTION_FAILED );
  }

 return( ROCSOLVER_STATUS_SUCCESS );

};



};
